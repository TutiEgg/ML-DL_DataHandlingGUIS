import string
import sys
import time
from threading import Thread

import json


# IMPORTING ALL THE NECESSERY PySide6 MODULES FOR OUR APPLICATION.

from PySide6 import QtCore, QtGui, QtWidgets
from PySide6.QtCore import (QCoreApplication, QPropertyAnimation, QDate, QDateTime, QMetaObject, QObject, QPoint, QRect,
                            QSize, QTime, QUrl, Qt, QEvent)
from PySide6.QtGui import (QBrush, QColor, QConicalGradient, QCursor, QFont, QFontDatabase, QIcon, QKeySequence,
                           QLinearGradient, QPalette, QPainter, QPixmap, QRadialGradient)
from PySide6.QtWidgets import *

from ui_settings import Ui_MainWindow as ui_sett  # MAINWINDOW CODE GENERATED BY THE QT DESIGNER AND PySide6-uic.
from ui_information import Ui_MainWindow as ui_info  # MAINWINDOW CODE GENERATED BY THE QT DESIGNER AND PySide6-uic.

# Hier muss noch das Projekt AIDataKit importiert werden => from read_create_files import *
from scripts import *


##########################################################################
# Info
# ui_element.currentText() => get selected combobox as a string
# ui_element.value() => get selected value of spinbox as a number
# ui_element.toPlainText() => get text of plaintext_object
##########################################################################

class WorkerThread(QtCore.QThread):

    def __init__(self, func):
        """
        Initialises the function specified in the function header

        Parameters
        ----------
        func :
            some function that should be initialised
        """

        super().__init__()
        self.func = func

    def run(self):
        """
        Calls func() when thread starts running.

        Returns
        -------

        """

        self.func()

    """
    def run(self):
        while(1):
            print("yes")
            self.add_line_historie("yes")
            self.timer = QtCore.QTimer()
            self.timer.setInterval(2000)

        str_output = self.reader.reader()  # self.readerscript(ser)
        if str_output:
            if str_output in self.table_content.keys():
                self.add_line_historie(self.table_content[str_output]["interpretation"])
                self.set_interpretation(self.table_content[str_output]["interpretation"],
                                        color=self.table_content[str_output]["farbe"])
            else:
                self.add_line_historie(str_output)
                self.set_interpretation(str_output, color='orange')

        """

class InfoWindow(QMainWindow):
    """
    Information-Gui called by Main-class (MainWindow)
    """
    def __init__(self, readerscript, serialport, usecase, table_content, parent=None):
        super(InfoWindow, self).__init__(parent)
        self.info_ui = ui_info()
        self.info_ui.setupUi(self)
        self.table_content = table_content  # dict of table_content. Keys = [row1, row2, ...], values = [datasend, interpretation, farbe]
        self.usecase = usecase  # String title
        self.serialport = serialport  #
        self.readerscript = readerscript
        self.reader = self.readerscript(self.serialport)

        # title
        applicationName = "GUI-Application"
        self.setWindowTitle(applicationName)

        # [Initialize Variables] ---------------------------------------------------------
        self.initialize_variables()

        print(self.table_content)

        self.start()

    def check_serial(self):
        """
        Continuously checks if reader has received data. If there is data, and it is in table_con, adds its
        interpretation to history which is being displayed on pop up window after clicking on start button.
        Otherwise, if there is data, but it is not in table_con, it just adds the data to history.

        Returns
        -------

        """
        while True:
            str_output = self.reader.reader()  # self.readerscript(ser)
            if str_output:
                if str_output in self.table_content.keys():
                    self.add_line_historie(self.table_content[str_output]["interpretation"])
                    self.set_interpretation(self.table_content[str_output]["interpretation"],
                                            color=self.table_content[str_output]["farbe"])
                else:
                    self.add_line_historie(str_output)
                    # self.set_interpretation(str_output, color='orange')


    def start(self):
        """
        Function creates and executes threads.

        Returns
        -------

        """

        # [Design Objects] ---------------------------------------------------------------
        # change padding, size, color of Gui-Objects

        # Show Information
        self.show_informations()

        # [Set Events] -------------------------------------------------------------------
        self.btn_save_run.clicked.connect(lambda: self.save_run())

        # [RUN]

        #readerThread = Thread(target=self.run)
        #readerThread.setDaemon(True)
        #readerThread.start()

        # self.thread = WorkerThread(self.check_serial)
        # self.thread.start()

        self.reader = self.readerscript(self.serialport)
        self.timer = QtCore.QTimer()
        self.timer.setInterval(250)
        self.timer.timeout.connect(self.run)
        self.timer.start()
        print("readerthread started")



    def closeEvent(self, event):
        """
        Function is called when the information window is being closed (terminates thread and closes event)

        Parameters
        ----------
        event :
            some event

        Returns
        -------

        """
        self.thread.quit()
        self.thread.wait()
        super(InfoWindow, self).closeEvent(event)

    def run(self):
        """
        Checks if reader has received data. If there is data, and it is in table_con, adds its
        interpretation to historie which is being displayed on pop up window after clicking on start button.
        Otherwise, if there is data, but it is not in table_con, it just adds the data to historie.

        Returns
        -------

        """
        str_output = self.reader.reader() #self.readerscript(ser)
        if str_output:
            if str_output in self.table_content.keys():
                self.add_line_historie(self.table_content[str_output]["interpretation"])
                self.set_interpretation(self.table_content[str_output]["interpretation"],
                                        color=self.table_content[str_output]["farbe"])
            else:
                self.add_line_historie(str_output)
                # self.set_interpretation(str_output, color='orange')

    def run_bak(self):
        print('runbak')
        reader = self.readerscript(self.serialport)
        while True:
            print('Test')
            str_output = reader.reader() #self.readerscript(ser)
            if str_output:
                if str_output in self.table_content.keys():
                    self.add_line_historie(self.table_content[str_output]["interpretation"])
                    self.set_interpretation(self.table_content[str_output]["interpretation"],
                                            color=self.table_content[str_output]["farbe"])
                else:
                    self.add_line_historie(str_output)
                    self.set_interpretation(str_output, color='orange')

                time.sleep(2)

    def show_informations(self):
        """
        Function adds html to browser_info so that the usecase, serialport, interpretation and all the information from
        the table appear in a grey information box once start button is clicked.

        Returns
        -------

        """
        #self.browser_info.append("<p><b>Readerscript:</b> {}</p>".format(self.readerscript))
        self.browser_info.append("<p><b>Usecase:</b> {}</p>".format(self.usecase))
        self.browser_info.append("<p><b>Serialport:</b> {}</p>".format(self.serialport))
        self.browser_info.append("<p><b>Interpretation:</b> </p> ")
        self.browser_info.setStyleSheet("background-color: grey;")
        for datasend in self.table_content:
            if datasend:
               color = self.table_content[datasend]["farbe"]
               interpretation = self.table_content[datasend]["interpretation"]
               self.browser_info.append("<p style='color:{};'>&nbsp;&nbsp;&nbsp;&nbsp;{} -> {}</p>".format(color, datasend, interpretation))



    def add_line_historie(self, text, color=None):
        """
        Function adds line to historie box that appears once start button is clicked.

        Parameters
        ----------
        text : str
            text that should appear in historie box
        color : str
            color of text

        Returns
        -------

        """
        if color is None:
            color = "black"
        self.browser_histo.append(f"<p style='color:{color}'>{text}</p>")

    def set_interpretation(self, text, color=None):
        """
        Function sets background colour and text that appear in pop up window after start button is clicked.

        Parameters
        ----------
        text : str
            text that appears in window
        color : str
            background colour of pop up window

        Returns
        -------

        """
        self.interpretation.setText(text)
        #self.interpretation.setStyleSheet('color: {}'.format(color))
        self.setStyleSheet("background-color: {};".format(color))

    def save_run(self):
        """
        Function which will be executed after button_click on the 'save_run'-button on the Main_Gui.
        It saves browser_histo in a log file at a location selected by the user.

        Returns
        -------

        """
        # get rows from historie
        browser_histo = self.browser_histo.toPlainText()

        # select file within explorer, must be a .log file
        print('Please select the location where you want to save your file. It must be a .log file.')
        file_path = QtWidgets.QFileDialog.getSaveFileName()[0]
        if file_path.endswith('.log'):
            with open(file_path, 'w') as log_file:
                log_file.write(browser_histo)
            print('save_run')
        elif file_path != '':
            with open(file_path+str('.log'), 'w') as log_file:
                log_file.write(browser_histo)
            print('save_run')


# [INIT- FUNCTIONS] ----------------------------------------------------------------------------------------------

    def initialize_variables(self):
        """
        Initialize all Variables given from QTDesigner and change them to local (manual-set) variables
        Returns
        -------

        """

        self.btn_save_run = self.info_ui.pushButton
        self.browser_histo = self.info_ui.textBrowser_historie
        self.browser_info = self.info_ui.textbrowser_information
        self.interpretation = self.info_ui.label_interpretation


class MainWindow(QMainWindow):
    """
    Main-class of GUI (Settings_gui)
    """
    def __init__(self):
        """
        Init
        """
        self.test_par = "YAAA"

        super(MainWindow, self).__init__()
        self.ui = ui_sett()
        self.ui.setupUi(self)

        # device_dict
        self.device_dict = {} # Key:device_name, Value:device_obj This Dict is constantly updated. (Check for plugged devices)

        # title
        applicationName = "GUI-Planung"
        self.setWindowTitle(applicationName)

        # [Label_lists] ------------------------------------------------------------------
        # Header labels for the table
        self.header_labels = ["Data Send", "Interpretation", "Farbe"]
        # readerscript strings
        self.readerscript_list = READERSCRIPT_LIST
        self.serialport_list = ["COM5", "testfile.txt", "kochenfile.txt"] # TODO: Hardcoded COMS

        # [Initialize Variables] ---------------------------------------------------------
        self.initialize_variables()

        # [Initialize Objects] -----------------------------------------------------------
        self.initialize_obj()

        # [Set Variables] ----------------------------------------------------------------
        # change label string for example
        self.initialize_table()

        # create info_gui object placeholder
        self.info_gui = None

        # [Start] ------------------------------------------------------------------------
        self.start()

    def start(self):
        """
        This function handles all main events
        Returns
        -------

        """

        # [Design Objects] ---------------------------------------------------------------
        # change padding, size, color of Gui-Objects
        self.resize_window()

        # [Set Events] -------------------------------------------------------------------
        self.btn_start.clicked.connect(lambda: self.start_btn())
        self.btn_load_settings.clicked.connect(lambda: self.load_settings())
        self.btn_save_settings.clicked.connect(lambda: self.save_settings())

                                                                    # Readerscript default always is given
        self.input_serialport.activated.connect(lambda: self.on_input_changed("serialport"))      # serialport_combobox constantly updated (default: nothing selected)
                                                                    # Usecase default is always given ?
        self.input_number.valueChanged.connect(lambda:self.on_input_changed("number"))          # Number default is none (=0)

        self.input_readerscript.activated.connect(lambda:self.on_input_changed("readerscript"))
        self.input_usecase.textChanged.connect(lambda: self.on_input_changed("usecase"))

        # [RUN] --------------------------------------------------------------------------

    # TODO: Not functioning right now
    def resize_window(self):
        """
        Function resizes the main window

        Returns
        -------

        """
        self.ui.label_serialport.resizeEvent = self.resizeText

    # TODO: Not functioning right now
    def resizeText(self, event):
        """
        Resizes the text

        Parameters
        ----------
        event :
            some event

        Returns
        -------

        """
        defaultSize = 40
        if self.rect().width() // 80 > defaultSize:
            f = QFont('', self.rect().width() // 80)
        else:
            f = QFont('', defaultSize)

    # [INIT- FUNCTIONS] ----------------------------------------------------------------------------------------------

    def initialize_variables(self):
        """
        Initialize all Variables given from QTDesigner and change them to local (manual-set) variables
        Returns
        -------

        """
        self.btn_save_settings = self.ui.btn_save
        self.btn_start = self.ui.btn_start
        self.btn_load_settings = self.ui.btn_load

        self.label_readerscript = self.ui.label_readerscript
        self.input_readerscript = self.ui.comboBox_input_readerscript

        self.label_serialport = self.ui.label_serialport
        self.input_serialport = self.ui.comboBox_serialport

        self.label_usecase = self.ui.label_usecase
        self.input_usecase = self.ui.text_usecase  # TODO: Change Name

        self.label_number = self.ui.text_output  # TODO: Change Name
        self.input_number = self.ui.spinBox_output  # TODO: Change Name

        self.table = self.ui.tableWidget

    def initialize_table(self):
        """
        Initialize table, in this case 3 cols and headers
        Returns
        -------

        """
        self.table.setColumnCount(3)
        self.table.setHorizontalHeaderLabels(self.header_labels)
        # Resize Header_cols
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Stretch)
        header.setSectionResizeMode(1, QHeaderView.Stretch)
        header.setSectionResizeMode(2, QHeaderView.ResizeToContents)

        # for later use
        # self.diag = dialogUi()
        # self.error = errorUi()
        """
            def dialogexec(self, heading, message, icon, btn1, btn2):
                dialogUi.dialogConstrict(self.diag, heading, message, icon, btn1, btn2)
                self.diag.exec_()

        #############################################################


        def errorexec(self, heading, icon, btnOk):
            errorUi.errorConstrict(self.error, heading, icon, btnOk)
            self.error.exec_()
        """

        """
        def moveWindow(event):
            # IF MAXIMIZED CHANGE TO NORMAL
            if UIFunction.returStatus(self) == 1:
                UIFunction.maximize_restore(self)

            # MOVE WINDOW
            if event.buttons() == Qt.LeftButton:
                self.move(self.pos() + event.globalPos() - self.dragPos)
                self.dragPos = event.globalPos()
                event.accept()
        """
        #############################################################

    def initialize_obj(self):
        """
        Function initialises objects, here the start button, readerscript combobox_content and the serialport.

        Returns
        -------

        """

        # Set Start button to not-clickable
        self.btn_start.setEnabled(False)
        # Set Button-tooltip

        # Set readerscript combobox_content
        self.input_readerscript.addItems([n.__name__ for n in READERSCRIPT_LIST])

        self.input_serialport.addItems(self.serialport_list)

    # [FUNCTIONS] ----------------------------------------------------------------------------------------------------

    def on_input_changed(self, changed_obj):
        """
        on input changed event, check input for correctness
        Parameters
        ----------
        changed_obj: Object which was changed (triggered event)

        Returns
        -------

        """
        # Check if number is changed (Number = tablerow)
        if changed_obj == "number":
            self.on_number_changed()

        # Boolean Variables
        check_readescript = True
        check_serialport = True
        check_usecase = True
        check_number = True

        tooltip_str = "" # Shows tooltip over start_btn if not all inputs are selected (If not all requirements are met)

        # Check if readescript is empty
        if str(self.input_readerscript.currentText()) == "":
            check_readescript = False
            tooltip_str += "\nReaderscript input is wrong"

        # Check if serialport selection is empty
        if self.input_serialport.currentText() == "":
            check_serialport = False #TODO undo this after adding devices_function
            tooltip_str += "\nserialport input is wrong"

        # Check if Usecase is empty
        if str(self.input_usecase.toPlainText()) == "":
            check_usecase = False
            tooltip_str += "\nusecase input is wrong"

        # Check if number is selected ( it has to be higher than 0 to be set true)
        if self.input_number.value() <= 0:
            check_number = False
            tooltip_str += "\nnumber input is wrong"

        self.btn_start.setToolTip(tooltip_str)
        if check_readescript and check_usecase and check_serialport and check_number:
            self.btn_start.setEnabled(True)
            print("se")
        else:
            self.btn_start.setEnabled(False)

    def start_btn(self):
        """
        Check if all inputs are correct and create info_gui
        Returns
        -------

        """
        def get_table_content(table):
            """
            Get table content and put it into a dictionary

            table_con : { datasend: {
                                        "interpretation": "",
                                        "farbe":        ""
                                    }
                        }
            Parameters
            ----------
            table

            Returns
            -------

            """
            table_con = {}

            for row in range(0, self.table.rowCount()):
                row_str = ""+ table.item(row, 0).text()
                table_con[row_str] = {
                    # TODO: Check for double keys -> error
                    "interpretation": table.item(row, 1).text(),
                    "farbe": table.cellWidget(row, 2).currentText()
                }

            return table_con

        readerscript = self.readerscript_list[self.input_readerscript.currentIndex()]
        serialport = self.input_serialport.currentText()
        usecase = self.input_usecase.toPlainText()
        table_content = get_table_content(self.table)

        print('Start butten used')
        # print('InfoWindow attributes', serialport, usecase, table_content)
        self.info_gui = InfoWindow(readerscript, serialport, usecase, table_content)
        self.info_gui.show()
        print("start settings")

    def save_settings(self):
        """
        Function which will be executed after button_click on the 'save_settings'-button on the Main_Gui (settings).
        Saves settings information in json file at a location selected by the user.

        Returns
        -------

        """

        ## maybe also deal with case where any of the values (or content in table) are not given (for which values is this possible?)

        # get values
        readerscript = self.input_readerscript.currentText()
        input_usecase = self.input_usecase.toPlainText()
        value = self.input_number.value()
        serialport = self.input_serialport.currentText()

        # get values from table
        table_con = {}
        table_rows = self.table.rowCount()
        for i in range(table_rows):
            data_send = self.table.item(i, 0).text()
            interpretation = self.table.item(i, 1).text()
            combobox = self.table.cellWidget(i, 2)
            if isinstance(combobox, QComboBox):
                farbe = combobox.currentText()
            else:
                print('[ERROR]: Drop-down menu not recognised as QCombobox -> Could not get the selected colour,'
                      'colour in file will be an empty string')
                farbe = ''

            row = [data_send, interpretation, farbe]
            table_con['row'+str(i)] = row

        file_content = {'Readerscript': readerscript, 'Serial Port': serialport, 'Usecase': input_usecase,
                        'Number Output': value, 'table_con': table_con}

        # select file within explorer, must be a json file
        print('Please select the location where you want to save your file. It must be a .json file')
        file_path = QtWidgets.QFileDialog.getSaveFileName()[0]

        if file_path.endswith('.json'):
            with open(file_path, 'w') as json_file:
                json.dump(file_content, json_file)

            print('save_settings')
        elif file_path != '':
            with open(file_path+str('.json'), 'w') as json_file:
                json.dump(file_content, json_file)

            print('save_settings')

    def load_settings(self):
        """
        Function which will be executed after button_click on the 'load_settings'-button on the Main_Gui (settings).
        Loads information of selected json file into variables so that information from file can be displayed.

        Returns
        -------

        """

        # select file within explorer
        print('Please select a file. It must be a .json file.')
        file_path = QtWidgets.QFileDialog.getOpenFileNames()[0][0]

        if file_path.endswith('.json'):
            # read from json file
            with open(file_path, 'r') as json_file:
                data = json.load(json_file)

            if 'Readerscript' in data:
                readerscript = data['Readerscript']
                list_readerscripts = [n.__name__ for n in READERSCRIPT_LIST]
                print(list_readerscripts)
                if readerscript in list_readerscripts:
                    readerscript_ind = list_readerscripts.index(readerscript)
                else:
                    print('[ERROR] readerscript not found in list of possible readerscripts. Please check if it is '
                          'spelled correctly.')
                    readerscript_ind = None
            else:
                print('[ERROR] readerscript not found. Please ensure it exists in file.')
                readerscript_ind = None

            if 'Serial Port' in data:
                serial_port = data['Serial Port']
                if serial_port in self.serialport_list:
                    serial_port_ind = self.serialport_list.index(serial_port)
                else:
                    print('[ERROR]: serial_port not in list, please check if serial_port is spelled correctly.')
                    serial_port_ind = None
            else:
                print('[ERROR]: No serial_port given.')
                serial_port_ind = None

            if 'Usecase' in data:
                usecase = data['Usecase']
            else:
                usecase = ''

            if 'Number Output' in data:
                num_output = data['Number Output']
            else:
                print('Number Output was not found in file -> set to default value: 0.')
                num_output = 0

            if 'table_con' in data:
                table_con = data['table_con']
            else:
                table_con = {}

            if len(table_con) != num_output:
                print(
                    '[ERROR] Table content should match number output but len(table_con) = {0} and num_output = {1}. '
                    'Table will have too many rows/ will not be complete. Please also check that the dictionary keys '
                    'in the file are spelled correctly.'.format(len(table_con), num_output))

            print(readerscript_ind)
            self.input_readerscript.setCurrentIndex(readerscript_ind)
            self.input_usecase.setPlainText(usecase)
            self.input_number.setValue(num_output)
            self.input_serialport.setCurrentIndex(serial_port_ind)

            self.input_number.valueChanged.connect(lambda: self.on_input_changed('number'))

            # set table content
            for i, key in enumerate(table_con):
                self.table.setItem(i, 0, QTableWidgetItem(table_con[key][0]))
                self.table.setItem(i, 1, QTableWidgetItem(table_con[key][1]))

                # select colour from
                combobox = self.table.cellWidget(i, 2)
                if isinstance(combobox, QComboBox):
                    index = combobox.findText(table_con[key][2], Qt.MatchFixedString)
                    combobox.setCurrentIndex(index)
        else:
            print('File must be a .json file. Please try again.')

    def on_number_changed(self):
        """
        If Output number is changed => resize the table (Number = rows of table)

        Returns
        -------

        """
        input_value = self.input_number.value()
        table_value = self.table.rowCount()

        diff_val = abs(input_value - table_value)  # Difference between input_value and table_row_value (abs)
        print(self.input_number.value(), table_value)

        if input_value > table_value:

            for i in range (0, diff_val):
                self.table.insertRow(table_value+i)
                # Add text to new row
                self.table.setItem(table_value+i,0, QTableWidgetItem(""))
                self.table.setItem(table_value+i, 1, QTableWidgetItem(""))

                # Create Combobox for Colors
                combobox_colors = QComboBox()
                combobox_colors.addItems(["Red", "Yellow", "Green", "Blue", "darkCyan"])
                self.table.setCellWidget(table_value+i, 2, combobox_colors)

        elif input_value < table_value:

            for i in range(0, diff_val):
                self.table.removeRow(self.table.rowCount()-1)


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())