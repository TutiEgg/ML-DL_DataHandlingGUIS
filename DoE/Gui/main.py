#TODO: DialogUI lambda funktionen übergeben
#TODO: Fragezeichen Icons zu jedem Input hinzufügen
#TODO: Anfang jeder Datei Allgemeine Variablenzuweisung
#TODO: HOVER_EFFEKTE per Allgemeinfunktion zu jedem objekt hinzufügen
#TODO: Bei klick auf icon oben links sollen Information zu derjenigen Seite angezeigt werden (Fast fertig)
#TODO: PLan_Seite sollen die Attribute anklickbar sein (fertig) und spezifische Informationen ausgeben (zeigt bei djedem Attribut das gleiche, muss gefixt werden)
#TODO: Settings editierbar (fertig)
#TODO: Repetitions zum Plan einfügen (fertig?)
#TODO: Plan_funktion lesen udn schreiben von Exceldateien überprüfungsfunktion
#TODO: In den Settings auf den loadbutton zu klicken läd abgepseicherte Settings in die dropdownbar. Dann sind standart settings und die geladenen settings in der Dropdownbar auswählbar.
#TODO: Man muss bei Experiment_objekten die repetition auch übergeben, aber die visualizierung und abspeicherung macht mehrerer Experiment objekte daraus , je nachdem wie viele reps


#TODO: Bei Keiner Auswahl vbeim Ladender Settings soll die Fehlermeldungn nicht kommen
#TODO: Filename sollte automatisch generiert werden.
# z.B 19-09-2023_{Parameter} => 19-09-2023_Pumpe-h02_machine-m01 oder 19-09-2023_P-h02_M-m01


# DESIGN
#TODO: Alles Rekursive machen
#TODO: Objekte struktuiert platzieren
#TODO: Design ändern (Farbe ...)
import os.path
import sys

# IMPORTING ALL THE NECESSERY PySide6 MODULES FOR OUR APPLICATION.

from PySide6 import QtCore, QtGui, QtWidgets
from PySide6.QtCore import (QCoreApplication, QPropertyAnimation, QDate, QDateTime, QMetaObject, QObject, QPoint, QRect, QSize, QTime, QUrl, Qt, QEvent)
from PySide6.QtGui import (QBrush, QColor, QConicalGradient, QCursor, QFont, QFontDatabase, QIcon, QKeySequence, QLinearGradient, QPalette, QPainter, QPixmap, QRadialGradient)
from PySide6.QtWidgets import *

from ui_main import Ui_MainWindow  # MAINWINDOW CODE GENERATED BY THE QT DESIGNER AND PySide6-uic.
from ui_dialog import Ui_Dialog  # DIALOGBOX
from ui_error import Ui_Error  # ERRORBOX
from ui_function import *  # A FILE WHERE ALL THE FUNCTION LIKE BUTTON PRESSES, SILDER, PROGRESS BAR ... ARE DONE.
from settings_function import *
from gui_stylesheet import Gui_stylesheet
from IO.read_create_files import *

from definitions import *



# GLOBAL-SETTINGS  ########################################################################

# CHANGE ORDER HERE: The Order of the list matches the order on the table-header
HEADER_LABELS = [
    "Experiment_name",  # DONT CHANGE THE NAME, ONLY THE ORDER
    "Executed_date",
    "Scheduled_date",
    "filename",
    "Run_costs",  # DONT CHANGE THE NAME, ONLY THE ORDER
    # "Repetitions"  # DONT CHANGE THE NAME, ONLY THE ORDER
]  # IF YOU CHANGE ANY OF THOSE: ("Experiment_name","Run_costs","Repetitions")  YOU HAVE TO CHANGE THEM IN main.py # load_plan TOO
# ATTRIBUTE_HEADERS ARE ADDED AFTERWARDS IN plan_function.py -> show_plan()



# DIALOGBOX CLASS WHICH MAKE THE DIALOGBOX WHEN CALLED.
# ------> DIALOG BOX CLASS : DIALOGBOX CONTAINING TWO BUTTONS, ONE MAEEAGE BAR, ONE ICON HOLDER, ONE HEADING DEFINING
class dialogUi(QDialog):
    def __init__(self, parent=None):
        super(dialogUi, self).__init__(parent)
        self.d = Ui_Dialog()
        self.d.setupUi(self)
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint)  # REMOVING WINDOWS TOP BAR AND MAKING IT FRAMELESS (AS WE HAVE AMDE A CUSTOME FRAME IN THE WINDOW ITSELF)
        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)  # MAKING THE WINDOW TRANSPARENT SO THAT TO GET A TRUE FLAT UI

        #############################################################################################                        -------(C1)
        # -----> MINIMIZE BUTTON OF DIALOGBOX
        self.d.bn_min.clicked.connect(lambda: self.showMinimized())

        # -----> CLOSE APPLICATION FUNCTION BUTTON
        self.d.bn_close.clicked.connect(lambda: self.close())

        # -----> THIS FUNCTION WILL CHECKT WEATHER THE BUTTON ON THE DIALOGBOX IS CLICKED, AND IF SO, DIRECTS TO THE FUNCTINON : diag_return()

        ##############################################################################################

        ##################################################################################################                        ------(C2)
        # ---> MOVING THE WINDOW WHEN LEFT MOUSE PRESSED AND DRAGGED OVER DIALOGBOX TOPBAR
        self.dragPos = self.pos()  # INITIAL POSOTION OF THE DIALOGBOX

        def movedialogWindow(event):
            # MOVE WINDOW
            if event.buttons() == Qt.LeftButton:
                self.move(self.pos() + event.globalPos() - self.dragPos)
                self.dragPos = event.globalPos()
                event.accept()

        # WIDGET TO MOVE
        self.d.frame_top.mouseMoveEvent = movedialogWindow  # CALLING THE FUNCTION TO CJANGE THE POSITION OF THE DIALOGBOX DURING MOUSE DRAG
        ################

    # ----> FUNCTION TO CAPTURE THE INITIAL POSITION OF THE MOUSE
    def mousePressEvent(self, event):
        self.dragPos = event.globalPos()

    #################################################################################################

    #################################################################################################                        ------(C3)
    # THE DIALOG BOX IS ABLE TO CHANGE THE STATE OF THE TEXT SHOWN, BUTTON NAMES E.T.C
    # THIS IS MADE BY CALLING THIS FUNCTION WHICH TAKES: HEADING, MESSAGE, ICON, BUTTON NAME 1, BUTTON NAME 2 AS ARUMENT.
    # -------> SETTING THE DIALOGBOX CONFIGRATION: TEXT IN BUTTON, LABEL, HEADING
    def dialogConstrict(self, heading, message, btn1, btn1_func, btn2, btn2_func, icon=None):
        self.d.lab_heading.setText(heading)
        self.d.lab_message.setText(message)

        self.d.bn_west.setText(btn1)
        self.d.bn_east.setText(btn2)
        # TODO:
        self.d.bn_west.clicked.connect(btn1_func)
        self.d.bn_east.clicked.connect(btn2_func)


        pixmap = QtGui.QPixmap(icon)
        self.d.lab_icon.setPixmap(pixmap)

    ##################################################################################################


# ERRORBOX CREATES A SMALL WINDOW TO DISPLAY THAT SOMETHING THAT THE USER PERFORMED HAS WENT WRONG.
# THIS CLASS ALSO HAS THE SAME PROPERTY AS THE DIALOGBOX CLASS WITH THE EXCEPTION THAT BOTH HAVE DIFFERENT UI INTERFACE ANS DIFFERENT APPLICATION.
# ------> ERROR BOX GIVING THE ERROR OCCURED IN THE PROCESS: TAKES THE HEADING, ICON AND BUTTON NAME
class errorUi(QDialog):
    def __init__(self, parent=None):
        super(errorUi, self).__init__(parent)
        self.e = Ui_Error()
        self.e.setupUi(self)
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint)
        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)

        # -----> CLOSE APPLICATION FUNCTION BUTTON: CORRESPONDING TO THE bn_ok OF THE ERRORBOX
        self.e.bn_ok.clicked.connect(lambda: self.close())

        # ---> MOVING THE WINDOW WHEN LEFT MOUSE PRESSED AND DRAGGED OVER ERRORBOX TOPBAR
        self.dragPos = self.pos()  # INITIAL POSOTION OF THE ERRORBOX

        def moveWindow(event):
            # MOVE WINDOW
            if event.buttons() == Qt.LeftButton:
                self.move(self.pos() + event.globalPos() - self.dragPos)
                self.dragPos = event.globalPos()
                event.accept()

        # WIDGET TO MOVE
        self.e.frame_top.mouseMoveEvent = moveWindow  # CALLING THE FUNCTION TO CJANGE THE POSITION OF THE ERRORBOX DURING MOUSE DRAG
        ################

    # ----> FUNCTION TO CAPTURE THE INITIAL POSITION OF THE MOUSE
    def mousePressEvent(self, event):
        self.dragPos = event.globalPos()

    #############################################

    # SAME AS DESCRIBED IN COMMEND (C3)
    # -------> SETTING THE ERRORBOX CONFIGRATION: TEXT IN BUTTON, LABEL, HEADING
    def errorConstrict(self, heading, icon, btnOk):
        self.e.lab_heading.setText(heading)
        self.e.bn_ok.setText(btnOk)
        pixmap2 = QtGui.QPixmap(icon)
        self.e.lab_icon.setPixmap(pixmap2)


# APPLICATION MAIN WINDOW :
# -----> MAIN APPLICATION CLASS
class MainWindow(QMainWindow):
    def __init__(self):

        super(MainWindow, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)

        # Save Plan after creating a Object
        self.plan_before = None

        # ----> SET WINDOW TITLE AND ICON
        applicationName = "Interface - Strategie"
        self.setWindowTitle(applicationName)  # SETS THE APPLICATION NAME IN THE WINDOW TOPBAR
        UIFunction.labelTitle(self, applicationName)  # PASSING THE CODE TO SET THE TITLE TO THE CUSTOME TOPBAR IN THE UI
        ###############################

        # -----> INITIAL STACKED WIDGET PAGE WIDGET AND TAB
        # THIS MAKE THE INITIAL WINDOW OF OUR APPLICATION, I.E. THE FIRST PAGE OR THE SETTINGS PAGE/SCREEN
        # IN OUR APPLICATION THIS IS THE MENU BAR, TOODLE SWITCH, MIN, MAX, CLOSE BUTTONS, AND THE HOME (SETTINGS) PAGE.
        # ALL THIS GET INITIALISED HERE.
        # SINCE ALL THE FUNCTION RELATED STUFF IS DONE IN THE ui_function.py FILE, IT GOES THERE
        UIFunction.initStackTab(self)
        ############################################################

        # ----> CERTAIN TOOLS LIKE DRAG, MAXIMISE, MINIMISE, CLOSE AND HIDING OF THE WINDOWS TOPBAR
        # THIS WINDOW INITIALISES THE BUTTONS NECESSERY FOR THE MAINWINDOW LIKE: CLOSE, MIN, MAX E.T.C.
        UIFunction.constantFunction(self)
        #############################################################



        # ----> EXECUTING THE ERROR AND DIALOG BOX MENU : THIS HELP TO CALL THEM WITH THE FUNCTIONS.
        # THIS CODE INITIALISED THE DIALOGBOX AND THE ERRORBOX, MAKES AN OBJECT OF THE CORRESPONDING CLASS, SO THAT ITS CALLABLE
        self.diag = dialogUi()
        self.error = errorUi()
        #############################################################

        # ----> INITIALIZE ALL OTHER FUNCTION FOR SUB_CONTENT LIKE SETTING, PLAN, RECORDINGS ...
        # Settings Initalize
        sett = Settings_function(self.ui, self.error, self.diag)
        sett.initialize_gui_elements()


        # Plan initialize
        # initialize buttons-event
        self.ui.button_plan_import.clicked.connect(lambda: self.load_plan())
        self.ui.button_plan_export.setEnabled(False) # Set on False

        # ----> TOODLE THE MENU HERE
        # THIS CODE DETETS THE BUTTON IN THE RIGHT TOP IS PRESSED OR NOT AND IF PRESSED IT CONNECT  TO A FUNCTION IN THE ui_function.py
        # FILE, WHICH EXPANDS THE MENU BAR TO DOUBLE ITS WIDTH (FULL_SCREEN).
        self.ui.toodle.clicked.connect(lambda: UIFunction.toodleMenu(self, 160, True))
        #############################################################



        # ----> MENU BUTTON PRESSED EVENTS
        # NOW SINCE OUR DEMO APPLICATION HAS ONLY 4 MENU BUTTONS: Home, Bug, Android, Cloud, WHEN USER PRESSES IT THE FOLLOWING CODE
        # REDIRECTS IT TO THE ui_function.py FILE buttonPressed() FUNCTION TO MAKE THE NECESSERY RESPONSES TO THE BUTTON PRESSED.
        self.ui.bn_settings.clicked.connect(lambda: UIFunction.buttonPressed(self, 'bn_settings'))
        self.ui.bn_plan.clicked.connect(lambda: UIFunction.buttonPressed(self, 'bn_plan'))
        self.ui.bn_recordings.clicked.connect(lambda: UIFunction.buttonPressed(self, 'bn_recordings'))
        #############################################################

        # ----> [MENU] -> SETTINGS BUTTON PRESSED EVENTS
        self.ui.button_settings_save.clicked.connect(lambda: sett.buttonPressed('bn_settings_save'))
        self.ui.button_settings_start.clicked.connect(lambda: sett.buttonPressed('bn_settings_start'))
        self.ui.button_settings_load.clicked.connect(lambda: sett.buttonPressed('bn_settings_load'))
        self.ui.button_settings_add_parameter.clicked.connect(lambda: sett.buttonPressed('bn_settings_add_parameter'))
        self.ui.button_settings_del_row.clicked.connect(lambda: sett.buttonPressed('bn_settings_del_row'))
        # TODO: MOVE THIS BUTTON_PRESS_EVENTS TO THE CORRESPONDING FILE: settings_function.py

        #self.ui.button_settings_del_row.valueChanged.connect(lambda: sett.buttonPressed('bn_settings_del_row'))



        # ----> [Design] -> SET CUSTOM DESIGNS
        Gui_stylesheet(self.ui)

        # Resize Plan-Table to Content
        self.ui.tableWidget_plan_show.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
        #self.ui.tableWidget_plan_show.resizeColumnToContents()
        self.ui.tableWidget_plan_show.setWordWrap(True)

        # Set the QTableWidget's columns width to fit the widget
        self.ui.tableWidget_plan_show.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        #self.ui.tableWidget_plan_show.horizontalHeader().setStretchLastSection(True)






        # -----> STACK PAGE FUNCTION
        UIFunction.stackPage(self)
        #############################################################




        # ---> MOVING THE WINDOW WHEN LEFT MOUSE PRESSED AND DRAGGED OVER APPNAME LABEL
        self.dragPos = self.pos()

        def moveWindow(event):
            # IF MAXIMIZED CHANGE TO NORMAL
            if UIFunction.returStatus(self) == 1:
                UIFunction.maximize_restore(self)

            # MOVE WINDOW
            if event.buttons() == Qt.LeftButton:
                self.move(self.pos() + event.globalPos() - self.dragPos)
                self.dragPos = event.globalPos()
                event.accept()

        # WIDGET TO MOVE: CHOOSE THE TOPMOST FRAME WHERE THE APPLICATION NAME IS PRESENT AS THE AREA TO MOVE THE WINDOW.
        self.ui.lab_user.mouseMoveEvent = moveWindow  # CALLING THE FUNCTION TO CHANGE THE POSITION OF THE WINDOW DURING MOUSE DRAG
        self.ui.lab_appname.mouseMoveEvent = moveWindow  # CALLING THE FUNCTION TO CHANGE THE POSITION OF THE WINDOW DURING MOUSE DRAG
        self.ui.frame_spacer.mouseMoveEvent = moveWindow  # CALLING THE FUNCTION TO CHANGE THE POSITION OF THE WINDOW DURING MOUSE DRAG
        self.ui.lab_person.mouseMoveEvent = moveWindow  # CALLING THE FUNCTION TO CHANGE THE POSITION OF THE WINDOW DURING MOUSE DRAG


    # ----> FUNCTION TO CAPTURE THE INITIAL POSITION OF THE MOUSE: NECESSERY FOR THE moveWindow FUNCTION
    def mousePressEvent(self, event):
        self.dragPos = event.globalPos()

    #############################################################

    # -----> FUNCTION WHICH OPENS THE DIALOG AND DISPLAYS IT:
    # IT TAKES DIALOG OBJECT(INITIALISED EARLIER), HEADER NAME OF DIALOG BOX, MESSAGE TO BE DISPLAYED, ICON, BUTTON NAMES.

    def dialogexec(self, heading, message, icon, btn1, btn2):
        self.diag.exec_()

    #############################################################

    # -----> FUNCTION WHICH OPENS THE ERROR BOX AND DISPLAYS IT
    def errorexec(self, heading, icon, btnOk):
        errorUi.errorConstrict(self.error, heading, icon, btnOk)
        self.error.exec_()
    ##############################################################

    def load_plan(self):
        """
        This function only loads a Excel-file and puts it into the plan_table
        Returns
        -------

        """

        if self.plan_before:
            self.plan_before.delete_plan()

            del self.plan_before  # TODO: Not needed anymore
            self.plan_before = None  # TODO: Not needed anymore

        """
        Imports a Plan out of an File selected through the Filebrowser
        Returns
        -------

        """
        # open file with fileexplorer

        path_to_file = QtWidgets.QFileDialog.getOpenFileName(QFileDialog(),
                                                             "Selected Plan",
                                                             os.path.join(ROOT_DIR, "DoE", "Plan"),
                                                             "csv files (.csv)|.csv|Excel Worksheets (*.xls, *.xlsx)| *.xls*")[0]


        if path_to_file:

            # read selected file

            df = read_excel_to_df(path_to_file)
            df_t = df.T

            data_dict = df_t.to_dict()

            # TODO: COSTS need to be fixed

            print(len(data_dict.keys()))
            print(data_dict)

            #{'Pumpe': 'h01', 'machine': 'm01'}

            exp_dict = {} # All Data  of Experiments in a dict
            experiment_list = [] # LIST OF ALL EXPERIMENTS FOR PLAN
            attr_list = [] # LIST OF ALL ATTRIBUTE_LABELS FOR PLAN
            attr_bool = False  # BOOL SO attr_list ONLY FILLS ONCE
            for id in data_dict:
                print(data_dict[id])
                exp = data_dict[id].copy()
                exp_name = exp.pop("Experiment_name")
                exp_dict[exp_name] = exp # ADD ALL DATA OF IN A DICTIONARY

                attribut_dict = {} # CREATE ATTRIBUTE_DICT

                for key, value in data_dict[id].items():
                    if key not in HEADER_LABELS: # IF NOT IN header_label_list THAN THE KEY IS AN ATTRIBUTE
                        if not attr_bool:

                            attr_list.append(Attribute(key, [], 0))
                        attribut_dict[key] = value
                attr_bool = True

                # run_cost = data_dict[id]["Run_costs"] #TODO: Not implemented right now
                experiment_obj = Experiment(exp_name, None, None)
                # ADD ATTRIBUTE-DCIT TO EXPERIMENT_OBJECT
                experiment_obj.attribute_dict = attribut_dict
                # ADD EXPERIMENT TO LIST
                experiment_list.append(experiment_obj)


            #  CREATE PLAN OBJECT
            plan = Plan("plan1")  # TODO: Change Plan-name maybe to the filename which this data was imported from
            plan.plan = experiment_list
            # CREATE PLAN_FUNCTION-OBJECT

            plan_obj = Plan_function(self.ui, self.error, self.diag, plan, attr_list)
            plan_obj.show_plan(exp_dict)

            self.plan_before = plan_obj
            print("End")

    def load_plan_and_create_plan(self):
        """
        This Function loads a plan (Excel) and creates a Plan-object out of it.
        This plan-object is visualized in the plan-table
        Returns
        -------

        """
        if self.plan_before:
            self.plan_before.delete_plan()

            del self.plan_before #TODO: Not needed anymore
            self.plan_before = None #TODO: Not needed anymore

        """
        Imports a Plan out of an File selected through the Filebrowser
        Returns
        -------

        """
        # open file with fileexplorer

        path_to_file = QtWidgets.QFileDialog.getOpenFileName(QFileDialog(),
                                                              "Selected Plan",
                                                              os.path.join(ROOT_DIR, "DoE", "Plan"), "csv files (.csv)|.csv|Excel Worksheets (*.xls, *.xlsx)| *.xls*")[0]


        if path_to_file:

            # init
            parameter_1_list = [] # SAVE DATA FOR CHECKBOXES
            parameter_2_list = [] # SAVE DATA FOR FILENAME_LABELS

            # read selected file
            df = read_excel_to_df(path_to_file)
            data_dict = df.to_dict()

            # CREATE EXPERIMENT FOR EACH ROW IN EXCEL-TABLE
            experiment_list = []

            # TODO: COSTS need to be fixed



            for s in range(0, len(data_dict[data_dict.keys()[0]])): # 0 to length of experiments
                # GET PARAMETER_1-VALUE (Filename) AND PUT INTO LIST
                parameter_1_list.append(data_dict[header_label_list[1]][s])
                # GET PARAMETER_2-VALUE (checkbox) AND PUT INTO LIST
                parameter_2_list.append(data_dict[header_label_list[0]][s])

                # CREATE EXPERIMENT
                exp = Experiment(data_dict[header_label_list[2]][s], None, None)
                # CREATE ATTRIBUTE_DICT
                attribute_dict = {}
                for key, value in data_dict.items():
                    # IF NOT IN header_label_list THAN THE KEY IS AN ATTRIBUTE
                    if key not in header_label_list:
                        attribute_dict[key] = data_dict[key][s]
                        print(data_dict[key][s], " = ", key)

                # ADD ATTRIBUTE-DCIT TO EXPERIMENT_OBJECT
                exp.attribute_dict = attribute_dict
                # ADD EXPERIMENT TO LIST
                experiment_list.append((exp))

            #  CREATE PLAN OBJECT
            plan = Plan("plan1") # TODO: Change Plan-name maybe to the filename which this data was imported from
            plan.plan = experiment_list
            # CREATE PLAN_FUNCTION-OBJECT
            plan_obj = Plan_function(self.ui, self.error, self.diag, plan)
            plan_obj.show_plan(parameter_1_list, parameter_2_list)

            self.plan_before = plan_obj



if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())

############################################################################################################################################################